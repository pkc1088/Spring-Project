- H2 SetUp
    - 다운로드 버전 : 2.2.224
    - 위치 : C:\Program Files (x86)\H2
    - 실행 : 인텔리제이 윈도우 파워쉘에서 C:\Program Files (x86)\H2\bin으로 이동 후 h2.bat 입력 or 그냥 폴더로 가서 클릭(이땐 콘솔창 끄면 안됨)
    - 최초 접근 : jdbc:h2:~/test 로 ~/test.mv.db를 pkc10에 생성
    - 이후 접근 : jdbc:h2:tcp://localhost/~/test
    - localhost:8082로도 접근 가능함
- JDBC
    -  JDBC 자바 표준이 등장
        - 기존의 문제는 각각의 데이터베이스마다 커넥션을 연결하는 방법, SQL을 전달하는 방법, 그리고 결과를 응답 받는 방법이 모두 다르다는 점
        - 데이터베이스를 다른 종류의 데이터베이스로 변경하면 애플리케이션 서버에 개발된 데이터베이스 사용 코드도 함 께 변경해야 한다.
        - 개발자가 각각의 데이터베이스마다 커넥션 연결, SQL 전달, 그리고 그 결과를 응답 받는 방법을 새로 학습해야 한다
        - JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API다
        - JDBC 표준 인터페이스는 그대로 사용하고 구현체인 MYSQL or Orcale 드라이버 등으로 바꿔끼우면 된다
        - 그러면 여전히 '커넥션 연결, SQL 전달, 결과 응답'을 애플리케이션 서버와 특정 DB간 교환할 수 있게 된다.
        - 최근에는 JDBC를 직접 사용하 기 보다는 JDBC를 편리하게 사용하는 다양한 기술이 존재한다. 대표적으로 SQL Mapper와 ORM 기술로 나눌 수 있다.
    - SQL Mapper
        - 장점: JDBC를 편리하게 사용하도록 도와준다. SQL 응답 결과를 객체로 편리하게 변환해준다. JDBC의 반복 코드를 제거해준다.
        - 단점: 개발자가 SQL을 직접 작성해야한다.
        - 대표 기술: 스프링 JdbcTemplate, MyBatis
    - ORM 기술
        - ORM은 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술이다.
        - 덕분에 개발자는 반복적인 SQL을 직접 작성하지 않고, ORM 기술이 개발자 대신에 SQL을 동적으로 만들어 실행해준다.
        - 추가로 각각 의 데이터베이스마다 다른 SQL을 사용하는 문제도 중간에서 해결해준다.
        - 대표 기술: JPA, 하이버네이트, 이클립스링크 JPA는 자바 진영의 ORM 표준 인터페이스이고, 이것을 구현한 것으로 하이버네이트(실무에서 주로 씀)와 이클립스 링크 등의 구현 기술이 있다.
    - ConnectionConst class
        - abstract으로 객체 선언을 막아 놓음 (인터페이스와의 차이는 다중 상속이 불가하다는 점), 내부 변수는 public으로 선언해서 외부에서 쓸 수 있게 해놓음
        - [☕ 인터페이스 vs 추상클래스 용도 차이점 - 완벽 이해](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
    - DBConnectionUtil class
        - DriverManager.getConnection(..) 를 사용하면 된다. 이렇게 하면 라이브러리에 있는 데이터베이스 드라이버를 찾아서 해당 드라이버가 제공하는 커넥션을 반환해준다.
        - 여기서는 H2 데이터베이스 드라이버가 작동해서 실제 데이터베이스와 커넥션을 맺고 그 결과를 반환
    - MemberRepositoryV0
        - ResultSet
            - ResultSet 은 다음과 같이 생긴 데이터 구조이다. 보통 select 쿼리의 결과가 순서대로 들어간다.
            - ResultSet 내부에 있는 커서( cursor )를 이동해서 다음 데이터를 조회할 수 있다
        - save()
            - pstmt.setString(1, member.getMemberId());
            - pstmt.setInt(2, member.getMoney()); 이렇게 테이블을 맵핑 시킨다
            - 항상 PreparedStatement pstmt를 연결한 뒤엔 finally로 close 해줘야 한다.
            - PreparedStatement 는 Statement 의 자식 타입인데, ? 를 통한 파라미터 바인딩을 가능하게 해준다. 참고로 SQL Injection 공격을 예방하려면 PreparedStatement 를 통한 파라미터 바인딩 방식을 사용해야 한다
            - pstmt.executeUpdate(); 로 실행한다
        - findById()
            - rs = pstmt.executeQuery() 데이터를 변경할 때는 executeUpdate() 를 사용하지만, 데이터를 조회 할 때는 executeQuery() 를 사용한다. executeQuery() 는 결과를 ResultSet 에 담아서 반환한다
            - rs.next()로 커서 역할을 한다
    - 커넥션 풀
        - 원래는 TCP/IP 커넥션을 새로 생성하기 위한 리소스를 매번 사용해야 한다
        - 커넥션을 미리 생성해두고 사용해서 해결한다
        - 커넥션 풀에 들어 있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이기 때문에 언제든지 즉시 SQL을 DB 에 전달할 수 있다.
        - 이제는 커넥션 풀을 통해 이미 생성되어 있는 커넥션을 객체 참조로 그냥 가져다 쓰기만 하면 된다. 커넥션 풀에 커넥션을 요청하면 커넥션 풀은 자신이 가지고 있는 커넥션 중에 하나를 반환한다.
        - 즉 디비에 사용 커넥션을 맺는게 아니라 커넥션 풀에서 조회한다.
        - 애플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용해서 SQL을 데이터베이스에 전달하고 그 결과를 받아서 처리한다. 커넥션을 모두 사용하고 나면 이제는 커넥션을 종료하는 것이 아니라, 다음에 다시 사용할 수 있도록 해당 커넥션 을 그대로 커넥션 풀에 반환하면 된다. 여기서 주의할 점은 커넥션을 종료하는 것이 아니라 커넥션이 살아있는 상 태로 커넥션 풀에 반환해야 한다는 것이다.
        - 불필요한 커넥션 맺는 시간을 줄이고 실제 sql을 던지고 처리하는 시간에만 영향을 받게 된다는 장점
        - 성능과 사용의 편리함 측면에서 최근에는 커넥션 풀 오픈소스로 hikariCP 를 주로 사용한다. 스프링 부트 2.0 부터는 기본 커넥션 풀 로 hikariCP 를 제공한다. 성능, 사용의 편리함, 안전성 측면에서 이미 검증이 되었기 때문에 커넥션 풀을 사용 할 때는 고민할 것 없이 hikariCP 를 사용하면 된다.
    - *DataSource*
        - 커넥션을 얻는 방법은 앞서 학습한 JDBC DriverManager 를 직접 사용하거나, 커넥션 풀을 사용하는 등 다양한 방법이 존재한다
        - 우리가 앞서 JDBC로 개발한 애플리케이션 처럼 DriverManager 를 통해서 커넥션을 획득하다가, 커넥션 풀을 사용하는 방법으로 변경하려면 어떻게 해야할까? 예를 들어서 애플리케이션 로직에서 DriverManager 를 사용해서 커넥션을 획득하다가 HikariCP 같은 커넥 션 풀을 사용하도록 변경하면 커넥션을 획득하는 애플리케이션 코드도 함께 변경해야 한다. 의존관계가 DriverManager 에서 HikariCP 로 변경되기 때문이다. 물론 둘의 사용법도 조금씩 다를 것이다
        - 자바에서는 이런 문제를 해결하기 위해 javax.sql.DataSource 라는 인터페이스를 제공한다. *DataSource는 커넥션을 획득하는 방법을 추상화 하는 인터페이스*이다. 이 인터페이스의 핵심 기능은 커넥션 조회 하나이다
        - 대부분의 커넥션 풀은 DataSource 인터페이스를 이미 구현해두었다. 따라서 개발자는 DBCP2 커넥션 풀 , HikariCP 커넥션 풀의 코드를 직접 의존하는 것이 아니라 DataSource 인터페이스에만 의존하도록 애플리 케이션 로직을 작성하면 된다. 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 갈아끼우기만 하면 된다. (스프링은 DriverManager 도 DataSource 를 통해서 사 용할 수 있도록 DriverManagerDataSource 라는 DataSource 를 구현한 클래스를 제공)
        - 자바는 DataSource 를 통해 커넥션을 획득하는 방법을 추상화했다. 이제 애플리케이션 로직은 DataSource 인터페이스에만 의존하면 된다. 덕분에 DriverManagerDataSource 를 통해서 DriverManager 를 사용 하다가 커넥션 풀을 사용하도록 코드를 변경해도 애플리케이션 로직은 변경하지 않아도 된다.
        - 스프링 부트는 기본적으로 *HikariCP*를 사용하여 DataSource를 자동 설정함. application.properties에 DB 연결 정보(spring.datasource.url 등)가 설정되면 HikariDataSource가 빈으로 등록됨.
    - ConnectionTest class
        - driverManager()
            - con1과 con2는 각각 getConnection(URL, USERNAME, PASSWORD)으로 커넥션을 획득할 때마다 이렇게 파라미터를 넣어서 호출해야함
        - dataSourceDriverManager()
            - DataSource를 사용하는 방식은 처음 객체를 생성할때만 필요한 파라미터를 넘겨두고, 커넥션을 획득할때는 단순히 getConnection()만 호출하면 된다.
            - 설정과 사용의 분리했다는 의의가 있다. 향후 변경에 유연하다
        - dataSourceConnectionPool()
            - MyPool connection adder : 별도의 쓰레드 사용해서 커넥션 풀에 커넥션을 채우고 있는 것을 확인할 수 있다. 이 쓰레드는 커넥션 풀에 커넥션을 최대 풀 수(10)까지 채운다. 그렇다면 왜 별도의 쓰레드를 사용해서 커넥션 풀에 커넥션을 채우는 것일까? 커넥션 풀에 커넥션을 채우는 것은 상대적으로 오래 걸리는 일이다. 애플리케이션을 실행할 때 커넥션 풀을 채울 때 까 지 마냥 대기하고 있다면 애플리케이션 실행 시간이 늦어진다. 따라서 이렇게 별도의 쓰레드를 사용해서 커넥션 풀을 채 워야 애플리케이션 실행 시간에 영향을 주지 않는다
    - MemberRepositoryV1
        - 외부에서 DataSource 를 주입 받아서 사용한다. 이제 직접 만든 DBConnectionUtil 을 사용하지 않 아도 된다. DataSource 는 표준 인터페이스 이기 때문에 DriverManagerDataSource 에서 HikariDataSource 로 변경되어도 해당 코드를 변경하지 않아도 된다.
        - close()를 JdbcUtils.closeResultSet(rs);을 통해 수행함
        - getConnection()도 의존관계 주입받은 dataSource객체로 진행함
        - *정리* : DriverManagerDataSource HikariDataSource 로 변경해도 MemberRepositoryV1 의 코드는 전혀 변 경하지 않아도 된다. MemberRepositoryV1 는 DataSource 인터페이스에만 의존하기 때문이다. 이것이 DataSource 를 사용하는 장점이다.(DI + OCP)
- 트랜잭션
    - ACID
        - 원자성(Atomicity), 일관성(Consistency), 격리 성(Isolation), 지속성(Durability)을 보장
        - 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.
        - 일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무 결성 제약 조건을 항상 만족해야 한다. 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터 를 수정하지 못하도록 해야 한다.
        - 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
        - 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이 터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다
    - 트랜잭션 격리 수준 : Isolation level
        - READ UNCOMMITED(커밋되지 않은 읽기)
        - READ COMMITTED(커밋된 읽기)
        - REPEATABLE READ(반복 가능한 읽기)
        - SERIALIZABLE(직렬화 가능)
    - 트랜젝션 락
        - SET LOCK_TIMEOUT 60000;
            - 세션1이 트랜잭션을 커밋하거나 롤백해서 종료하지 않았으므로 아직 세션1이 락을 가지고 있다. 따라서 세션2는 락을 획득하지 못하기 때문에 데이터를 수정할 수 없다. 세션2는 락이 돌아올 때 까지 대기하게 된다
    - 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.
    - 비즈니스 로직이 잘못되면 해당 비즈니스 로직 으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다. 그런데 트랜잭션을 시작하려면 커넥션이 필요하다.
    - 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 한다. 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야한다. 그래야 같 은 세션을 사용할 수 있다
    - MemberRepositoryV2
        - 애플리케이션에서 같은 커넥션을 유지하려면 어떻게 해야할까? 가장 단순한 방법은 커넥션을 파라미터로 전달해서 같 은 커넥션이 사용되도록 유지하는 것이다
        - findbyid와 update 메서드는 getConnection으로 생성하는게 아니라 파라미터로 커넥션을 받아 그 con을 일관되게 써야함.
        - close 할 때도 파라미터의 con을 닫아선 안됨
        - 즉 서비스 계층에서 con을 연결해주고 서비스 계층에서 con을 close 해줘야한다. 이 CRUD를 담당하는 repositoryv2에선 그걸 결정해선 안됨
        - 커넥션 유지가 필요한 두 메서드는 리포지토리에서 커넥션을 닫으면 안된다. 커넥션을 전달 받은 리포지토 리 뿐만 아니라 이후에도 커넥션을 계속 이어서 사용하기 때문이다. 이후 서비스 로직이 끝날 때 트랜잭션을 종료하고 닫아야 한다.
- 애플리케이션 구조
    - 프레젠테이션 계층
        - UI와 관련된 처리 담당
        - 웹 요청과 응답
        - 사용자 요청을 검증
        - 주 사용 기술: 서블릿과 HTTP 같은 웹 기술, 스프링 MVC
    - 서비스 계층
        - 비즈니스 로직을 담당
        - 주 사용 기술: 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성
    - 데이터 접근 계층
        - 실제 데이터베이스에 접근하는 코드
        - 주 사용 기술: JDBC, JPA, File, Redis, Mongo ..
- *스프링의 트랜잭션*
    - *트랜잭션 추상화*
        - 심지어 데 이터 접근 기술에 따른 트랜잭션 구현체도 대부분 만들어두어서 가져다 사용하기만 하면 된다.
        - 스프링 트랜잭션 추상화의 핵심은 PlatformTransactionManager 인터페이스이다.
        - 참고 : 스프링 5.3부터는 JDBC 트랜잭션을 관리할 때
            - DataSourceTransactionManager를 상속받아서 약간의 기능을 확장한
            - JdbcTransactionManager를 제공한다. 둘의 기능 차이는 크지 않으므로 같은 것으로 이해하 면 된다.
    - *리소스 동기화*
        - 스프링은 트랜잭션 동기화 매니저를 제공한다. 이것은 쓰레드 로컬을 사용해서 커넥션을 동기화해준다. 트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용한다.
        - 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 때문에 멀티쓰레드 상황에 안전하게 커넥션을 동기화 할 수 있다. 따라서 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다. 따라서 이전처럼 파라미터로 커넥션을 전달하지 않아도 된다
    - 트랜잭션 동작 원리
        1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
        2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다. (이젠 커넥션을 내가 들고 파라미터로 넘기거나 하지 않음)
        3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다 (해당 커넥션은 이미 트랜잭션이 시작된 커넥션이다). 따라서 파라미터로 커넥션을 전달하지 않아도 된다.
        4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.
        - 트랜잭션 매니저에서 커밋이나 롤백을 담당하고 커넥션을 닫는다.
        - 참고 : 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여된다. 따라서 해당 쓰레드만 해당 데이터에 접근 할 수 있다
    - MemberRepositoryV3
        - 트잭 동기화를 사용하려면 DataSourceUtils를 사용해야 함
        - getConnection()
            - DataSourceUtils를 이용해 getConnection(dataSource)를 한다 (데이터접근로직인 리포지토리에서 트잭 동기화 매니저로부터 보관된 커넥션을 꺼내는 거임)
            - 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다.
            - 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 새로운 커넥션을 생성해서 반환한다
            - 따라서 트잭이 true이든 false이든 둘 다 동작이 가능하다
        - close()
            - DataSourceUtils.releaseConnection(con, dataSource); 해줘야 한다
            - 트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
            - 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다
            - 즉 트잭 동기화 매니저에서 가져온거면 안 닫고 트잭 상황이 아니면 커넥션 닫는다.
        - 나머지 save, update, find는 MemberRepositoryV1과 동일함 (V2의 파라미터로 con 넘기는 방식을 쓰지 않음)
    - MemberServiceV3_1
        - 서비스 계층에서 트랜잭션 매니저를 통해 트잭을 시작하는 행위
        - transactionManager.getTransaction()을 통해 받아온 TransactionStatus 이용함
        - transactionManager.commit/rollback을 트라이캐치에서 수행함. 기존의 release는 트잭매니저가 커밋롤백시 알아서 처리하니 지워도 됨
        - V2에서는 직접 dataSource를 주입 받았는데 이젠 MemberServiceV3_1Test로 테스트 시 주입해주면 됨
        - JDBC 기술을 사용하기에 new DataSourceTransactionManager (dataSource)로 주입 받으면 된다.
        - 즉 서비스계층에서 어떤 dataSource를 받을지 강제하고 있지 않는거니 추상화가 잘 된거임 만약 JPA쓸거면 JpaTransactionManager로 바꾸면됨
    - *흐름 정리*
        - 클라이언트의 요청으로 서비스 로직을 실행한다.
        1. 서비스 계층에서 transactionManager.getTransaction() 을 호출해서 트랜잭션을 시작한다.
        2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성한다.
        - 이떄 dataSource는 테스트 코드에서 JDBC기술을 사용하는 DriverManagerDataSource의 객체인 dataSource를 PlatformTransactionManager의 구현체인 DataSourceTransactionManager의 파라미터로 넘겨서 얻어진거임
        3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다. (스프링이 알아서)
        4. 커넥션을 트랜잭션 동기화 매니저에 보관한다. (스프링이 알아서)
        5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관 할 수 있다. (스프링이 알아서
        6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. 이때 커넥션을 파라미터로 전달하지 않는다.
        7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는 DataSourceUtils.getConnection() 을 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 이 과정을 통해서 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지된다.
        8. 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.
        9. 서비스 계층은 비즈니스 로직이 끝나고 트랜잭션을 종료한다. 트랜잭션은 커밋하거나 롤백하면 종료된다.
        10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
        11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
        12. 전체 리소스를 정리한다.
            1. 트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용후 꼭 정리해야 한다.
            2. con.setAutoCommit(true) 로 되돌린다. 커넥션 풀을 고려해야 한다. con.close() 를 호출해셔 커넥션을 종료한다.
            3. 커넥션 풀을 사용하는 경우 con.close() 를 호출하면 커넥션 풀에 반환된다
- 트랜잭션 템플릿
    - MemberServiceV3_2
        - txTemplate.executeWithoutResult((status) ->로 트잭 시작과 커밋/롤백을 진행해준다. 이제 우리는 bizLogic인 비즈니스 로직만 생각하면 됨
        - 트잭 시작과 끝의 반복되는 코드를 줄였다는 의의가 있음
- *트랜잭션 AOP*
    - 프록시 도입 전: 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다.
    - 프록시 도입 후: 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에 실제 서 비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다
    - 스프링이 제공하는 트랜잭션 AOP
        - 스프링이 제공하는 AOP 기능을 사용하면 프록시를 매우 편리하게 적용할 수 있다.
        - 스프링 핵심 원리 - 고급편을 통해 AOP를 열심히 공부하신 분이라면 아마도 @Aspect , @Advice , @Pointcut 를 사용해서 트랜잭션 처리용 AOP를 어떻게 만들지 머리속으로 그림이 그려질 것이다. 물론 스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만, 트랜잭션은 매우 중요한 기능이고, 전세계 누구 나 다 사용하는 기능이다. 스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다.
        - 스프링 부트를 사용하 면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록해준다. 개발자는 트랜잭션 처리가 필요한 곳에 *@Transactional*만 붙여주면 된다. 스프링의 트랜잭션 AOP는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다.
        - MemberServiceV3_3Test에 @SpringBootTest 넣어줘야 스프링을 띄워서 @Transaction을 인식하고 처리해준다. 그리고 datSource나 변수들을 빈등록 해줘야함. 그래야 프록시에서 갖다 쓸 수 있음 (사실 지워도 됨)
        - AOP 프록시가 의존관계를 주입 받은 거임
- *스프링 부트의 자동 리소스 등록*
    - 스프링 부트가 등장하기 이전에는 데이터소스와 트랜잭션 매니저를 개발자가 직접 스프링 빈으로 등록해서 사용했다. 그런데 스프링 부트로 개발을 시작한 개발자라면 데이터소스나 트랜잭션 매니저를 직접 등록한 적이 없을 것이다.
    - 데이터소스 - 자동 등록
        - 스프링 부트는 데이터소스( DataSource )를 스프링 빈에 자동으로 등록한다.
        - 자동으로 등록되는 스프링 빈 이름: dataSource
        - 이때 스프링 부트는 다음과 같이 application.properties 에 있는 속성을 사용해서 DataSource 를 생성한다. 그리고 스프링 빈에 등록한다
        - 참고로 개발자가 직접 데이터소스를 빈으로 등록하면 스프링 부트는 데이터소스를 자동으로 등록하지 않는다.
        - 스프링 부트가 기본으로 생성하는 데이터소스는 커넥션풀을 제공하는 HikariDataSource 이다.
        - 커넥션풀과 관련된 설정도 application.properties 를 통해서 지정할 수 있다. spring.datasource.url 속성이 없으면 내장 데이터베이스(메모리 DB)를 생성하려고 시도한다.
    - 트랜잭션 매니저 - 자동 등록
        - 스프링 부트는 적절한 트랜잭션 매니저(PlatformTransactionManager )를 자동으로 스프링 빈에 등록한다.
        - 자동으로 등록되는 스프링 빈 이름: transactionManager
        - 참고로 개발자가 직접 트랜잭션 매니저를 빈으로 등록하면 스프링 부트는 트랜잭션 매니저를 자동으로 등록하지 않는다
        - 어떤 트랜잭션 매니저를 선택할지는 현재 등록된 라이브러리를 보고 판단하는데, JDBC를 기술을 사용하면 DataSourceTransactionManager 를 빈으로 등록하고, JPA를 사용하면 JpaTransactionManager 를 빈으 로 등록한다. 둘다 사용하는 경우 JpaTransactionManager 를 등록한다. 참고로 JpaTransactionManager는 DataSourceTransactionManager 가 제공하는 기능도 대부분 지원한다.
- 예외 처리
    - 예외 상속 계층 그림 확인하기
    - 체크 vs 언체크(런타임)
        - 체크 예외: 예외를 잡아서 처리하지 않으면 항상 throws 에 던지는 예외를 선언해야 한다.
        - 언체크 예외: 예외를 잡아서 처리하지 않아도 throws 를 생략할 수 있다.
    - 웹 애플리케이션이라면 서블릿의 오류 페이지나, 또는 스프링 MVC가 제공하는 ControllerAdvice 에서 이런 예외를 공통으로 처리한다.
        - 이런 문제들은 보통 사용자에게 어떤 문제가 발생했는지 자세히 설명하기가 어렵다. 그래서 사용자에게는 "서비스에 문제가 있습니다." 라는 일반적인 메시지를 보여준다.
        - API라면 보통 HTTP 상태코드 500(내부 서버 오류)을 사용해서 응답을 내려준다
    - throws SQLException, ConnectException 처럼 예외를 던지는 부분을 코드에 선언하는 것이 왜 문제가 될 까? 바로 서비스, 컨트롤러에서 java.sql.SQLException 을 의존하기 때문에 문제가 된다 (Jdbc 기술임).
    - 따라서 언체크(런타임) 예외로 바꿔서 해결한다
    - 런타임 예외는 문서화를 잘해야 한다.
    - 또는 코드에 throws 런타임예외 을 남겨서 중요한 예외를 인지할 수 있게 해준다.
    - 예외를 전환할 때는 꼭! 기존 예외를 포함하자. *Throwable*
- 스프링의 예외 처리, 반복
    - 서비스가 처리할 수 없으므로 리포지토리가 던지는 SQLException 체크 예외를 런타임 예외로 전환해서 서비스 계 층에 던지자. 이렇게 하면 서비스 계층이 해당 예외를 무시할 수 있기 때문에, 특정 구현 기술에 의존하는 부분을 제거하고 서비스 계층을 순수하게 유지할 수 있다
    - SQLException이 체크 예외이기 때문에 MemberRepository 인터페이스에도 해당 체크 예외가 선언 되어 있어야 한다. 따라서 우린 repository의 CRUD를 다 런타임으로 바꾸고 MemberRepository 인터페이스를 구현하는 방식으로 만들어서 인터페이스화 시킴과 동시에 SQLException을 선언하지 않아도 되도록 만들 것임
    - SQLException을 런타임예외로 감싸서 던질거라 MyDbException을 만듦
        - MemberRepositoryV4_1에서 throw new MyDbException(e); 로 던지기만 하면 됨
        - 만약 예외를 잡아서 처리하고 싶으면 SQLException 대신 MyDuplicateKeyException로 던져서 처리하면 됨
    - 스프링의 예외 변환기
        - SQLExceptionTranslator : 스프링은 데이터베이스에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다.
        - 드디어 예외에 대한 부분을 깔끔하게 정리했다. 스프링이 예외를 추상화해준 덕분에, 서비스 계층은 특정 리포지토리의 구현 기술과 예외에 종속적이지 않게 되었다. 따 라서 서비스 계층은 특정 구현 기술이 변경되어도 그대로 유지할 수 있게 되었다. 다시 DI를 제대로 활용할 수 있게 된 것이다. 추가로 서비스 계층에서 예외를 잡아서 복구해야 하는 경우, 예외가 스프링이 제공하는 데이터 접근 예외로 변경되어서 서비스 계층에 넘어오기 때문에 필요한 경우 예외를 잡아서 복구하면 된다
    - *JdbcTemplate*
        - MemberRepositoryV5
        - JDBC를 더 쉽게 사용할 수 있도록 도와주는 스프링의 유틸리티 클래스
        - 커넥션 열고 닫고 반복되는 코드를 모두 알아서 관리해줌