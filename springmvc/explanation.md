이제 JSP를 쓰지않고 Thymeleaf를 이용한 Spring MVC를 구축함
- Jar를 사용하면 항상 내장 서버(톰캣등)를 사용하고, webapp 경로도 사용하지 않습니다. 내장 서버 사용에 최적화 되어 있는 기능입니다. 최근에는 주로 이 방식을 사용합니다. War를 사용하면 내장 서버도 사용가능 하지만, 주로 외부 서버에 배포하는 목적으로 사용합니다.
- 스프링 부트에 Jar 를 사용하면 /resources/static/ 위치에 index.html 파일을 두면 Welcome 페이지로 처리해준다. (스프링 부트가 지원하는 정적 컨텐츠 위치에 /index.html 이 있으면 된다.

- sout으로 로그 찍지 말고 Logger를 이용해서 앞으로 로깅을 출력한다
- @RestController
    - @Controller는 뷰를 반환(뷰를 찾고 뷰가 랜더링됨)하는데 @RestController는 반환하는 스트링이 그냥 그대로 문자로 반환됨. 즉 HTTP 메시지 바디에 바로 입력함
    - RestAPI 만들때 핵심적인 기능임
- 로그 LEVEL: TRACE > DEBUG > INFO > WARN > ERROR
    - 개발할땐 Debug 레벨, 운영할 땐 INFO 정도로 셋팅함 (그러면 Trace, Debug 로그를 안찍음)
    - 근데 sout은 레벨 상관없이 다 출력하기에 안좋다. 요청이 수만개 있으면 로그가 지저분하게 다 남아버리니
    - 또 sout은 콘솔에만 남길수 있는데 로그는 파일로 뽑아낼 수 있다
    - log.debug("String concat log=" + name); 이 방식을 쓰면 안됨. debug 레벨 까지 안쓰더라도 자바 특성상 name을 "spring"으로 치환하고 저 두 문자열을 합치는것 까지 해버려 리소스 낭비임.
    - @Slf4j 붙이면 Log 쓸 수 있음
- @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
    - = @GetMapping(value = "/mapping-get-v2")
- @PathVariable로 경로변수를 사용해서 리소스 경로에 식별자를 넣는 스타일 많이 씀
- @PostMapping(value = "/mapping-consume", consumes = "application/json")
    - 헤더의 컨텐트 타입이 json일 때만 호출이 됨. 당연히 POST일때만 됨
    - 컨슘은 요청에서의 요청 헤더의 그 Content 타입 기반으로 맵핑
- HTTP 요청 Accept, produce
    - 프로듀스는 그 요청 헤더의 업셉트 기반으로 요거가 맵핑이 됩니다
- 요청 매핑 - API 예시 : MappingClassController 
    - 이런 계층적인 방식을 *가장 많이 씀*

- RequestParamController
    - log.info("username={}, age={}", memberName, memberAge); 하면 중괄호 안에 변수 담아서 로그 출력됨
    - response.getWriter().write("ok");하면 앞서 설명했듯이 값 ok가 바로 페이지에 출력
    - string으로 ok를 리턴할땐 class에 @RestController로 바꾸거나 아니면 해당 메소드에 @ResponseBody를 붙여주면 ok라는 문자 메세지를 http 응답메세지에 담아서 반환한다. 즉 뷰 리졸브를 진행하지 않음
- resources 폴더의 /static 등의 html은 외부에 다 공개된다 (jar에는 war의 web-app경로가 없기에 여기에 다 넣으면 스프링부트가 알아서 내장 톰캣으로 서빙해준다)
- hello-form.html 방식은 post 방식 사용했음
- @RequestParam은 Http 요청의 쿼리/폼 데이터를 컨트롤러 메서드의 파라미터로 바인딩할 때 사용되는거임
- required는 디폴트 true이고 Http에서 해당 파라미터가 꼭 들어와야함을 보장해줌

- 실제 개발을 하면 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 한다 HelloData의 객체를 생성하고 셋, 겟해줘야함
- 스프링은 이 과정을 완전히 자동화해주는 @ModelAttribute 기능을 제공한다
    - 롬복 @Data : @Getter , @Setter , @ToString , @EqualsAndHashCode , @RequiredArgsConstructor 를 자동으로 적용해줌. 개사기인듯
    - 즉 @ModelAttribute가 객체 생성 후 @Data를 통해 @Setter하고 @Getter까지 다 지원해줌
    - @ModelAttribute 는 생략할 수 있다. 그런데 @RequestParam 도 생략할 수 있으니 혼란이 발생할 수 있다
        - 스프링은 해당 생략시 다음과 같은 규칙을 적용한다. 
        - String , int , Integer 같은 단순 타입 = @RequestParam 
        - 나머지 = @ModelAttribute (argument resolver(HttpServletResponse와 같은 예약어) 로 지정해둔 타입 외)

- RequestBodyStringController
    - 스트림은 바이트코드이다. 바이트코드로 문자를 받을 때는 어떤 인코딩으로 해서 문자를 바꿀 거야라고 항상 지정해 줘야함
- C:\Users\pkc10\AppData\Local\Postman-Agent
    - Postman Desktop App은 Electron(Chromium 엔진) 기반이라 UI를 렌더링하면서 GPU 가속을 활용하는데,
    - Postman Desktop Agent는 단순한 네트워크 요청 처리 도구이므로, GPU 사용이 거의 없음.
    - 따라서, NVIDIA 드라이버와 직접적인 충돌이 발생할 가능성이 낮음.
- *HttpEntity*: HTTP header, body 정보를 편리하게 조회
    - HttpMessageConverter 사용
    - 메시지 바디 정보를 직접 조회 / 응답시 반환
    - 요청 파라미터를 조회하는 기능과 관계 없음 (@RequestParam X, @ModelAttribute X) <- 얘네는 url 쿼리 방식으로 오는거에만 해당되는 내용임
    - 당연히 view 조회 (뷰 리졸버 등) 안 함 
- HttpEntity도 간소화 하기 위해 @RequestBody(요청), @ResponseBody(응답) 써버려도 됨. *실무는 이 방식을 많이 쓴다*
    - 앞서 설명했듯 @ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다. 물론 이 경우에도 view를 사용하지 않는다
    - 이게 /request-body-string-v4 이다.
    - 앞선 ResponseBody는 url 쿼리 방식에서 동작 과정이고 이건 string으로 http 메시지 바디로 통신할때의 처리 과정임
- 정리
    - 요청 파라미터 vs HTTP 메시지 바디 
        - 요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute 
        - HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody

- RequestBodyJsonController
    - v5 : 요청도 json 데이터 형태로 받고, 응답도 json 데이터 형태로 메세지 바디에 담음
    - 즉 json이 객체가 됐다가, 객체가 나갈땐 json이 컨버팅 됨
- 뷰 템플릿 경로 src/main/resources/templates가 기본임. 변경 필요하면 application.properties에서 설정 가능
- @RequestMapping("/response-view-v2")에 @ResponseBody 넣으면 뷰를 만들지 않고 리턴 스트링을 메세지 바디에 담아버리니 페이지가 뜨지 않음 (당연함)
- @RestController = @ResponseBody + @Controller
- 정리
    - basic/reqeust : @PostMapping은 클라이언트가 데이터를 **전송**할 때 사용.
    - basic/response : @GetMapping은 클라이언트가 데이터를 **조회**하거나 서버 상태를 확인할 때 사용.

- 스프링의 RequestMappingHandlerAdapter
    - 에노테이션 기반 컨트롤러를 처리하는 어뎁터이다.
    - *ArgumentResolver* : HttpServletRequest , Model은 물론이고, @RequestParam , @ModelAttribute 같은 애노테이션 그리고 @RequestBody , HttpEntity 같은 HTTP 메시지를 처리하는 부분 등을 RequestMappingHandlerAdapter가 ArgumentResolver를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다. 그리고 이렇게 파리미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다
    - *ReturnValueHandler* : 위와 비슷한 원리로 컨트롤러의 반환 값을 변환해주는 역할을 함. 즉 어떤 핸들러(컨트롤러)가 핸들러어뎁터한테 값을 반환할때 이 핸들러를 거쳐 간다. 즉 응답값을 변환하고 처리함
    - *Http 메세지 컨버터* : ArgumentResolver와 ReturnValueHandler가 사용함. 단순한건 ArgumentResolver/ReturnValueHandler 선에서 처리하는데 @RequestBody나 HttpEntity처럼 HTTP 메세지 바디를 처리해야할때는 Http 메세지 컨버터를 호출해야함

- 이전 내용 : `GET` 파라미터로 HTML 폼 데이터를 처리하는 방식은 폼 데이터가 URL에 쿼리 스트링 형태로 포함되어 전송되는 방식입니다. 이는 데이터를 쉽게 공유하거나 캐싱할 수 있는 장점이 있지만, 보안이나 데이터 크기 면에서는 제한이 있을 수 있습니다.
    - /process?name=Alice&age=30